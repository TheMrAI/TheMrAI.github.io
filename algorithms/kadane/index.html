<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge,chrome=1"><title>Kadane`s algorithm &#9775; MrAI</title><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="A brilliant way for solving the maximal subsequence problem (or maximal sub-array). One of those specialized algorithms that makes you truly appreciate the genius of others'."><link rel="shortcut icon" href=https://themrai.github.io/favicon.png type=image/x-icon><link rel=stylesheet href=https://themrai.github.io/pico/css/pico.min.css></head><body class=body><main class=container><nav><ul><li><a href=/>MrAI</a></li></ul><ul><li><a href=/algorithms/>Algorithms</a></li><li><a href=/contemplation/>Contemplation</a></li><li><a href=/tinkering/>Tinkering</a></li></ul></nav><article><p>For a given one-dimensional input array of numbers, Kadane&rsquo;s algorithm will
find the maximum <strong>positive</strong> sum, from all possible continuous sub-arrays.</p><h3 id=description>Description</h3><p>The array can contain positive, negative values and zero. The trick behind
the algorithms brilliant simplicity comes from the constraint that it will
only maximize sub-arrays that have positive sums. If no such
sub-arrays exist, the returned value will be zero.</p><p>The implementation is strikingly simple. Iterate through the elements and
keep summing them up. If this sum ever dips below zero then set it to zero.
When the rolling sum exceeds the maximum sum seen, then set it as the
maximum. Continue until there are remaining elements.</p><p>Since the algorithm isn&rsquo;t concerned with negative sums it can zero the
rolling sum whenever that dips below zero. Conceptually this means, that
the next maximum positive sum cannot contain the current or the previous
elements, because by summing them up, the value would turn negative. Thus,
if a sub-array with a total positive sum bigger than what we have already
seen exists, it must start from the next element.</p><h3 id=examples>Examples</h3><h4 id=general-input>General input</h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>Input: [1, 3, 4, -2, -1, -7, 11, -7, 6, -2, 4]
</span></span><span style=display:flex><span>Output: 12
</span></span></code></pre></div><p>By -5 the sum reached zero, the biggest sum can only be after, starting with 11.</p><h4 id=only-negative-values>Only negative values</h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>Input: [-1, -2, -3, -4, -5]
</span></span><span style=display:flex><span>Output: 0
</span></span></code></pre></div><p>Maximum positive sum cannot be negative, so the returned value is 0.</p><h3 id=illustration>Illustration</h3><figure><img src=kadane_illustration.png><figcaption><h4>Kadane</h4></figcaption></figure><h3 id=complexity>Complexity</h3><p>Time: O(n)</p><p>Space: O(1)</p><p>No hidden constant complexity. Each element has to be truly seen only once.</p><h3 id=example-implementation>Example implementation</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>template</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>typename</span> T<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span>T kadane(std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>const</span><span style=color:#f92672>&amp;</span> input)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>auto</span> maximal_sum{ <span style=color:#ae81ff>0</span> };
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>auto</span> current_sum{ <span style=color:#ae81ff>0</span> };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>auto</span> element : input)
</span></span><span style=display:flex><span>  {
</span></span><span style=display:flex><span>    current_sum <span style=color:#f92672>+=</span> element;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (current_sum <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>      current_sum <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    maximal_sum <span style=color:#f92672>=</span> std<span style=color:#f92672>::</span>max(maximal_sum, current_sum);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> maximal_sum;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></article><footer><nav aria-label=breadcrumb><ul><li><a href=/>Home</a></li><li><a href=/algorithms>Algorithms</a></li><li><a href=/algorithms/kadane>Kadane</a></li></ul></nav></footer></main></body></html>