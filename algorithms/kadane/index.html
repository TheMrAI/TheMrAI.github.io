<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge,chrome=1"><title>Kadane`s algorithm | MrAI</title><meta name=viewport content="width=device-width,minimum-scale=1"><meta name=description content="For a given one-dimensional input array of numbers, Kadane&rsquo;s algorithm will find the maximum positive sum, from all possible continuos sub-arrays.
Description The array can contain positive, negative values and zero. The trick behind the algorithms brilliant simplicity comes from the constraint that it will only maximize sub-arrays that have positive sums. If no such sub-arrays exist, the returned value will be zero.
The implementation is strikingly simple. Iterate trough the elements and keep summing them up."><meta name=generator content="Hugo 0.101.0"><meta name=robots content="noindex, nofollow"><link rel=stylesheet href=/ananke/css/main.min.css><meta property="og:title" content="Kadane`s algorithm"><meta property="og:description" content="For a given one-dimensional input array of numbers, Kadane&rsquo;s algorithm will find the maximum positive sum, from all possible continuos sub-arrays.
Description The array can contain positive, negative values and zero. The trick behind the algorithms brilliant simplicity comes from the constraint that it will only maximize sub-arrays that have positive sums. If no such sub-arrays exist, the returned value will be zero.
The implementation is strikingly simple. Iterate trough the elements and keep summing them up."><meta property="og:type" content="article"><meta property="og:url" content="https://themrai.github.io/algorithms/kadane/"><meta property="article:section" content="algorithms"><meta itemprop=name content="Kadane`s algorithm"><meta itemprop=description content="For a given one-dimensional input array of numbers, Kadane&rsquo;s algorithm will find the maximum positive sum, from all possible continuos sub-arrays.
Description The array can contain positive, negative values and zero. The trick behind the algorithms brilliant simplicity comes from the constraint that it will only maximize sub-arrays that have positive sums. If no such sub-arrays exist, the returned value will be zero.
The implementation is strikingly simple. Iterate trough the elements and keep summing them up."><meta itemprop=wordCount content="298"><meta itemprop=keywords content><meta name=twitter:card content="summary"><meta name=twitter:title content="Kadane`s algorithm"><meta name=twitter:description content="For a given one-dimensional input array of numbers, Kadane&rsquo;s algorithm will find the maximum positive sum, from all possible continuos sub-arrays.
Description The array can contain positive, negative values and zero. The trick behind the algorithms brilliant simplicity comes from the constraint that it will only maximize sub-arrays that have positive sums. If no such sub-arrays exist, the returned value will be zero.
The implementation is strikingly simple. Iterate trough the elements and keep summing them up."></head><body class="ma0 avenir bg-near-white"><header><div class=bg-black><nav class="pv3 ph3 ph4-ns" role=navigation><div class="flex-l justify-between items-center center"><a href=/ class="f3 fw2 hover-white no-underline white-90 dib">MrAI</a><div class="flex-l items-center"><ul class="pl0 mr3"><li class="list f5 f4-ns fw4 dib pr3"><a class="hover-white no-underline white-90" href=/algorithms/ title="Algorithms page">Algorithms</a></li><li class="list f5 f4-ns fw4 dib pr3"><a class="hover-white no-underline white-90" href=/contemplations/ title="Contemplations page">Contemplations</a></li><li class="list f5 f4-ns fw4 dib pr3"><a class="hover-white no-underline white-90" href=/tinkering/ title="Tinkering page">Tinkering</a></li></ul><div class=ananke-socials></div></div></div></nav></div></header><main class=pb7 role=main><article class="flex-l flex-wrap justify-between mw8 center ph3"><header class="mt4 w-100"><aside class="instapaper_ignoref b helvetica tracked">ALGORITHMS</aside><div id=sharing class="mt3 ananke-socials"></div><h1 class="f1 athelas mt3 mb1">Kadane`s algorithm</h1></header><div class="nested-copy-line-height lh-copy serif f4 nested-links mid-gray pr4-l w-two-thirds-l"><p>For a given one-dimensional input array of numbers, Kadane&rsquo;s algorithm will
find the maximum <strong>positive</strong> sum, from all possible continuos sub-arrays.</p><h3 id=description>Description</h3><p>The array can contain positive, negative values and zero. The trick behind
the algorithms brilliant simplicity comes from the constraint that it will
only maximize sub-arrays that have positive sums. If no such
sub-arrays exist, the returned value will be zero.</p><p>The implementation is strikingly simple. Iterate trough the elements and
keep summing them up. If this sum ever dips below zero then set it to zero.
When the rolling sum exceeds the maximum sum seen, then set it as the
maximum. Continue until there are remaining elements.</p><p>Since the algorithm isn&rsquo;t concerned with negative sums it can zero the
rolling sum whenever that dips below zero. Conceptually this means, that
the next maximum positive sum cannot contain the current or the previous
elements, because by summing them up, the value would turn negative. Thus
if a sub-array with a total positive sum bigger than what we have already
seen exists, it must start from the next element.</p><h3 id=examples>Examples</h3><h4 id=general-input>General input</h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>Input: [1, 3, 4, -2, -1, -7, 11, -7, 6, -2, 4]
</span></span><span style=display:flex><span>Output: 12
</span></span></code></pre></div><p>By -5 the sum reached zero, biggest sum can only be after, starting with 11.</p><h4 id=only-negative-values>Only negative values</h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>Input: [-1, -2, -3, -4, -5]
</span></span><span style=display:flex><span>Output: 0
</span></span></code></pre></div><p>Maximum positive sum cannot be negative, so the returned value is 0.</p><h3 id=illustration>Illustration</h3><p><img src=kadane_illustration.png alt=kadane></p><h3 id=complexity>Complexity</h3><p>Time: O(n)</p><p>Space: O(1)</p><p>No hidden constant complexity. Each element has to be truly seen only once.</p><h3 id=example-implementation>Example implementation</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>template</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>typename</span> T<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span>T kadane(std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>const</span><span style=color:#f92672>&amp;</span> input)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>auto</span> maximal_sum{ <span style=color:#ae81ff>0</span> };
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>auto</span> current_sum{ <span style=color:#ae81ff>0</span> };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>auto</span> element : input)
</span></span><span style=display:flex><span>  {
</span></span><span style=display:flex><span>    current_sum <span style=color:#f92672>+=</span> element;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (current_sum <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>      current_sum <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    maximal_sum <span style=color:#f92672>=</span> std<span style=color:#f92672>::</span>max(maximal_sum, current_sum);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> maximal_sum;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul class=pa0></ul><div class="mt6 instapaper_ignoref"></div></div><aside class="w-30-l mt6-l"></aside></article></main><footer class="bg-black bottom-0 w-100 pa3" role=contentinfo><div class="flex justify-between"><a class="f4 fw4 hover-white no-underline white-70 dn dib-ns pv2 ph3" href=https://themrai.github.io/>&copy; MrAI 2022</a><div><div class=ananke-socials></div></div></div></footer></body></html>