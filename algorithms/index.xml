<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Algorithms on MrAI</title><link>https://themrai.github.io/algorithms/</link><description>Recent content in Algorithms on MrAI</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><atom:link href="https://themrai.github.io/algorithms/index.xml" rel="self" type="application/rss+xml"/><item><title>Dynamic programming</title><link>https://themrai.github.io/algorithms/dynamic_programming/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://themrai.github.io/algorithms/dynamic_programming/</guid><description>Name The origin of the term dynamic programming is an interesting one. Two legends are in circulation. One from the author Richard Bellman stating that it was designed to hide the mathematical background of his work from his employer at the time. Choosing dynamic as it has no negative connotations and to refer to the time varying, multistage nature of the problems. Programming was chosen because it didn&amp;rsquo;t contain the word mathematics, and it sounded better than planning.</description></item><item><title>Kadane`s algorithm</title><link>https://themrai.github.io/algorithms/kadane/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://themrai.github.io/algorithms/kadane/</guid><description>For a given one-dimensional input array of numbers, Kadane&amp;rsquo;s algorithm will find the maximum positive sum, from all possible continuous sub-arrays.
Description The array can contain positive, negative values and zero. The trick behind the algorithms brilliant simplicity comes from the constraint that it will only maximize sub-arrays that have positive sums. If no such sub-arrays exist, the returned value will be zero.
The implementation is strikingly simple. Iterate through the elements and keep summing them up.</description></item><item><title>Longest Common Subsequence</title><link>https://themrai.github.io/algorithms/longest_common_subsequence/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://themrai.github.io/algorithms/longest_common_subsequence/</guid><description>The textbook example (literally) problem is the Longest Common Subsequence. Found in Introduction to Algorithms, Third Edition by Thomas H. Cormen, Charles E. Leiserson, Ronald L. Rivest, Clifford Stein Chapter 15.4. Perhaps not the most difficult problem, but one that illustrates the usefulness of dynamic programming very effectively.
Problem statement Given two sequences of characters, X=[x₁, x₂, x₃, &amp;hellip;, xₙ] and Y=[y₁, y₂, y₃, &amp;hellip;, yₘ], find the longest common subsequence (later LCS) Z=[z₁, z₂, z₃, &amp;hellip;, zₖ] where n, m, k &amp;gt;= 1 and n, m, k ∈ ℕ.</description></item></channel></rss>