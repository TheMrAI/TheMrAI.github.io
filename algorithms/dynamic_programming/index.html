<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge,chrome=1"><title>Dynamic programming &#9775; MrAI</title><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="An advanced way for designing solutions. What features does a problem need to display so that this type of solution can be applied? If those are satisfied we can transform algorithms with exponential time complexity to polynomial ones, by sacrificing on space."><link rel="shortcut icon" href=https://themrai.github.io/favicon.png type=image/x-icon><link rel=stylesheet href=https://themrai.github.io/pico/css/pico.min.css></head><body class=body><main class=container><nav><ul><li><a href=/>MrAI</a></li></ul><ul><li><a href=/algorithms/>Algorithms</a></li><li><a href=/contemplation/>Contemplation</a></li><li><a href=/tinkering/>Tinkering</a></li></ul></nav><article><h2 id=name>Name</h2><p>The origin of the term dynamic programming is an interesting one. Two legends are
in circulation. One from the author <a href=https://en.wikipedia.org/wiki/Richard_E._Bellman>Richard Bellman</a>
stating that it was designed to hide the mathematical background of
his work from his employer at the time. Choosing dynamic as it has no negative
connotations and to refer to the time varying, multistage nature of the problems.
Programming was chosen because it didn&rsquo;t contain the word mathematics, and it
sounded better than planning.
The other legend refers to an attempt to one up the previously existing methods
named linear programming.</p><h2 id=applicability>Applicability</h2><p>Dynamic programming is not an algorithm that solves a problem. It is a design
technique that speeds up a specific set of problems. When properly applied it can
transform algorithms from exponential ùí™(x‚Åø) to polynomial ùí™(nx) time
complexity for a comparably small, but usually not negligible space requirement of
around ùí™(nx).</p><p>It is most commonly used for optimization problems. In these problems the goal is
to either maximize of minimize the value function in question. The result is
one of the possible optimal solutions in a space where more than one can exist.</p><p>There are 2 requirements that need to be satisfied before dynamic programming can
be applied:</p><ul><li>The problem has to have an <strong>optimal substructure</strong></li><li>The solution must be constructed of <strong>overlapping subproblems</strong></li></ul><h3 id=optimal-substructure>Optimal substructure</h3><p>If an optimal solution to the problem consists of independent and
optimal solutions to its subproblems then we say the problem exhibits an
optimal substructure.</p><p>There are 3 steps used while testing for optimal substructure:</p><ol><li>Show that the solution to the problem consists of making a choice after which
the problem space separates into one or more independent subproblems, where each
exhibits the same properties as the original problem.</li><li>Assume that for a given problem there exists an optimal choice.</li><li>Show using the &ldquo;cut-and-paste&rdquo; method that given an optimal solution to a
problem the resulting subproblem solutions have to be optimal as well.</li></ol><blockquote><p>Independent optimal solutions: For a problem <strong>A</strong> comprised of subproblems
<strong>B</strong> and <strong>C</strong>, the optimal solutions for <strong>B</strong> and <strong>C</strong> are said to be
independent if they do not use up resources from on one
another. I.e. the solution for B does note use sub-solutions from C and vice-versa.</p></blockquote><blockquote><p>Cut-and-paste: Suppose that each subproblem solution is non-optimal. By cutting
them out and substituting an optimal solution, demonstrate that you get a better
solution to the original problem, which contradicts your original assumption of
already having an optimal solution to your original problem.</p></blockquote><h3 id=overlapping-subproblems>Overlapping subproblems</h3><p>Subproblems are considered overlapping when the solution for them share a common
set of subproblems among them.</p><p>The implication of this requirement is that the set of distinct subproblems
is small compared to the total set of subproblems that would need to be visited
while applying a brute force approach in solving the problem.</p><h2 id=design-steps>Design steps</h2><p>Developing an algorithm using dynamic programming is not a simple task. Especially
as dynamic programming itself isn&rsquo;t a way of designing per se, more of a way of
redesigning an already existing solution to a format which is more efficient.</p><p>The steps for applying dynamic programming:</p><ol><li>Understand and solve the problem in a recursive fashion.</li><li>Reformat the recursive algorithm to use dynamic programming.</li><li>(Optional) Reconstruct the optimal solution.</li></ol><h3 id=1-understand-and-solve-the-problem-in-a-recursive-fashion>1. Understand and solve the problem in a recursive fashion</h3><p>The problem we are trying to solve should lead us to an observation such as this:</p><p>&ldquo;To solve (optimize) <strong>problem</strong> <strong>X</strong> I have to make a globally optimal <strong>choice</strong>
while considering the result of all <strong>subproblems Xi</strong> for any of which
I do not know the answers for.&rdquo;</p><p>In other words we can define how an optimal solution will look like from the
top-down. The solution on the top level relies on the solutions of the
subproblems having the same basic format on lower levels.</p><h3 id=2-reformat-the-recursive-algorithm-to-use-dynamic-programming>2. Reformat the recursive algorithm to use dynamic programming</h3><p>There are two ways to do this. Use either a top-down approach or a bottom-up one.
In essence both of them are the same, they both solve the problems from the bottom
up, they are just defined differently. In practice the bottom-up approach is
preferable as it will most likely need fewer supporting structures to be
maintained, thus reducing time and space complexity.</p><h4 id=top-down>Top-down</h4><p>A top-down approach is the same as the above recursive implementation with the
added step of <strong>memoization</strong>. The method entails memoizing (memorizing) the
solution to an already solved sub-problem, so when it is encountered again, it
needs not be recomputed.</p><blockquote><p>Memoization could be called memorization as the values are memorized, but
historically this step was called memoization, based on the Latin word <a href=https://en.wikipedia.org/wiki/Memoization#Etymology>memorandum</a>.</p></blockquote><h4 id=bottom-up>Bottom-up</h4><p>The bottom-up approach is a bit different as the procedure has to be turned around.
Requires much more insight into how the algorithm is structured and what data has
to be calculated exactly when. Which sub-problems are dependencies to sub-problems
above them. With these questions answered one has to transform the algorithm such
that each sub-problem result is only calculated once and stored into an
appropriate container. By accessing the finally calculated value in this container
we receive the solution to the problem.</p><p>A noticeable difference between the top-down and bottom-up implementation is that
now there is no more recursion. The value is calculated in an iterative manner by
solving the problems in the direction from the smallest sub-problem towards the
original problem.</p><blockquote><p>In implementations the container used to store the values to the sub-problems is
usually called <strong>dp</strong>, to signal to the reader of the code that a <strong>dynamic
programming</strong> solution is what they are observing.</p></blockquote><h3 id=3-optional-reconstruct-the-optimal-solution>3. (Optional) Reconstruct the optimal solution</h3><p>Dynamic programming identifies the optimal value, but it doesn&rsquo;t necessarily
provide the solution itself. The solution most commonly is the chain of choices
made while calculating the optimal values. These could be characters chosen in the
<strong>Longest Common Subsequence</strong> problem, optimal piece sizes in the <strong>Rod Cutting
Problem</strong> or any other piece of information that describes an optimal solution.</p><h2 id=acknowledgements>Acknowledgements</h2><p>The information on this page heavily relies on chapter <em>15 Dynamic Programming</em>
from <strong>Introduction to Algorithms, Third Edition by Thomas H. Cormen, Charles E.
Leiserson, Ronald L. Rivest, Clifford Stein</strong>. For detailed explanations, examples
and the mathematical background please refer to the source.</p></article><footer><nav aria-label=breadcrumb><ul><li><a href=/>Home</a></li><li><a href=/algorithms>Algorithms</a></li><li><a href=/algorithms/dynamic_programming>Dynamic programming</a></li></ul></nav></footer></main></body></html>